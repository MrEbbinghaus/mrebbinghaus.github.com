<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REPL adventures</title>
  <link href="https://blog.ebbinghaus.me/atom.xml" rel="self"/>
  <link href="https://blog.ebbinghaus.me/"/>
  <updated>2022-04-01T21:17:03.679694Z</updated>
  <id>https://blog.ebbinghaus.me/</id>
  <author>
    <name>Björn Ebbinghaus</name>
  </author>
  <entry>
    <id>https://blog.ebbinghaus.me/fulcro-explained-1.html</id>
    <link href="https://blog.ebbinghaus.me/fulcro-explained-1.html"/>
    <title>Fulcro Explained 1</title>
    <category term="clojure" label="clojure"/>
    <category term="tutorial" label="tutorial"/>
    <category term="fulcro" label="fulcro"/>
    <published>2022-02-02T00:00:00Z</published>
    <updated>2022-02-02T00:00:00Z</updated>
    <content type="html">
      <![CDATA[<p>In this article, I will explain the core principles behind <a href="https://github.com/fulcrologic/fulcro">Fulcro</a>.
I will show you how to organize state in a normalized graph database and how to write basic components to utilize it.</p>
<p>For a complete run-trough I recommend reading the <a href="https://book.fulcrologic.com/" rel="nofollow">Fulcro Book</a> or looking into the <a href="https://fulcro-community.github.io/main/index.html" rel="nofollow">community tutorials</a>.</p>
<h2>
<a id="user-content-your-first-components" class="anchor" href="#your-first-components" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Your first components</h2>
<p>Imagine, you are building a social-network kind of application, and you want to implement a profile page:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">ns</span> <span class="pl-e">fulcro.tutorial</span>
  (<span class="pl-c1">:require</span> 
    [com.fulcorlogic.fulcro.components <span class="pl-c1">:as</span> comp <span class="pl-c1">:refer</span> [<span class="pl-k">defsc</span>]]
    [com.fulcrologic.fulcro.dom <span class="pl-c1">:as</span> dom <span class="pl-c1">:refer</span> [div p h2 ul li img]]))

(<span class="pl-k">defn</span> <span class="pl-e">profile-page</span> []
  (<span class="pl-en">div</span>
    (<span class="pl-en">p</span>
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>Spouse<span class="pl-pds">"</span></span>)
      (<span class="pl-en">div</span> 
        (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> <span class="pl-s"><span class="pl-pds">"</span>alice.png<span class="pl-pds">"</span></span>}) 
        <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>)
    (<span class="pl-en">p</span>
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>My Friends<span class="pl-pds">"</span></span>)
      (<span class="pl-en">ul</span>
        (<span class="pl-en">li</span> (<span class="pl-en">div</span> 
             (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> <span class="pl-s"><span class="pl-pds">"</span>alice.png<span class="pl-pds">"</span></span>}) 
             <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>))
        (<span class="pl-en">li</span> (<span class="pl-en">div</span> 
             (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> <span class="pl-s"><span class="pl-pds">"</span>bob.png<span class="pl-pds">"</span></span>}) 
             <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>))
        (<span class="pl-en">li</span> (<span class="pl-en">div</span> 
             (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> <span class="pl-s"><span class="pl-pds">"</span>charlie.png<span class="pl-pds">"</span></span>}) 
             <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>))))))</pre></div>
<p>But that's not why you are here. You are a programmer. You don't hard code information, and you don't write large functions. You want to break things apart and reuse them:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defn</span> <span class="pl-e">person</span> [{<span class="pl-c1">:keys</span> [name profile-pic-href]}]
  (<span class="pl-en">div</span>
    (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> profile-pic-href})
    name))

(<span class="pl-k">defn</span> <span class="pl-e">friend-list</span> [friends]
 (<span class="pl-en">ul</span> 
   (<span class="pl-k">for</span> [friend friends]
     (<span class="pl-en">li</span> (<span class="pl-en">person</span> friend)))))

(<span class="pl-k">defn</span> <span class="pl-e">profile-page</span> [{<span class="pl-c1">:keys</span> [spouse friends]}]
  (<span class="pl-en">div</span>
    (<span class="pl-en">p</span> 
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>Spouse<span class="pl-pds">"</span></span>)
      (<span class="pl-en">person</span> spouse))
    (<span class="pl-en">p</span>
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>My Friends<span class="pl-pds">"</span></span>)
      (<span class="pl-en">friend-list</span> friends))))</pre></div>
<p>Great, now you can feed the data like this to your function:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">def</span> <span class="pl-e">data</span>
    {<span class="pl-c1">:spouse</span> {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>
              <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>alice.png<span class="pl-pds">"</span></span>}
     <span class="pl-c1">:friends</span> [{<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>
               <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>alice.png<span class="pl-pds">"</span></span>}
              {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>
               <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>bob.png<span class="pl-pds">"</span></span>}
              {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>
               <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>charlie.png<span class="pl-pds">"</span></span>}]})</pre></div>
<p>This looks fine for the <em>state</em> of your client... BUT</p>
<p>Did you notice, that you have the data for your spouse twice?
What do you do, when you want to change the profile picture?
You will have to remember every place where you put that link! Terrifying!</p>
<p>A function for this could look like this:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defn</span> <span class="pl-e">update-profile-pic</span> [data {<span class="pl-c1">:keys</span> [name new-profile-pic-href]}]
 (<span class="pl-en">-&gt;</span> data
   (<span class="pl-en">assoc-in</span> [<span class="pl-c1">:spouse</span> <span class="pl-c1">:profile-pic-href</span>] new-profile-pic-href)
   (<span class="pl-en">update</span> <span class="pl-c1">:friends</span> 
           #(<span class="pl-en">map</span> 
             (<span class="pl-k">fn</span> [friend]
               (<span class="pl-k">if</span> (<span class="pl-en">=</span> name (<span class="pl-c1">:name</span> friend)
                 (<span class="pl-en">assoc</span> friend <span class="pl-c1">:profile-pic-href</span> new-profile-pic-href)
                 friend)))
             %))))</pre></div>
<h2>
<a id="user-content-data-normalization" class="anchor" href="#data-normalization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data Normalization</h2>
<p>But you can avoid this mess, by preventing the duplication.</p>
<p>Imagine you organize your data with references like this:</p>
<div class="highlight highlight-source-clojure"><pre>{<span class="pl-c1">:person</span> {<span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>
          {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>
           <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>alice.png<span class="pl-pds">"</span></span>}
          <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>
          {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>
           <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>bob.png<span class="pl-pds">"</span></span>}
          <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>
          {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>
           <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>charlie.png<span class="pl-pds">"</span></span>}}
 <span class="pl-c1">:spouse</span> [<span class="pl-c1">:person</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>]
 <span class="pl-c1">:friends</span> [[<span class="pl-c1">:person</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>] [<span class="pl-c1">:person</span> <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>] [<span class="pl-c1">:person</span> <span class="pl-s"><span class="pl-pds">"</span>Charlie<span class="pl-pds">"</span></span>]]}</pre></div>
<p>A vector like <code>[:person "Alice"]</code> is really nothing different like the vector you would use for <code>get-in</code>, <code>assoc-in</code> and <code>update-in</code>.</p>
<p>Now the ugly update function from above becomes as simple as:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defn</span> <span class="pl-e">update-profile-pic</span> [data {<span class="pl-c1">:keys</span> [name new-profile-pic-href]}]
 (<span class="pl-en">update-in</span> data [<span class="pl-c1">:person</span> name] 
   assoc <span class="pl-c1">:profile-pic-href</span> new-profile-pic-href)</pre></div>
<p>But what about our render functions? They don't know or care about references or duplication. All they want is their data to render.</p>
<p>This is where Fulcro comes to the rescue.
Fulcro is first and foremost only about solving this problem.
How to organize data so that they can be modified easily, but at the same time feed it to my render functions?</p>
<h2>
<a id="user-content-introducing-components-and-the-defsc-macro" class="anchor" href="#introducing-components-and-the-defsc-macro" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introducing components and the <code>defsc</code> macro.</h2>
<p>Components are a representation of a piece of data in our state.
The <code>defsc</code> macro allows us to define the data a component depends on (<em>query</em>)
and how to the reference (called <em>ident</em>) to this data looks like.</p>
<div class="highlight highlight-source-clojure"><pre><span class="pl-c"><span class="pl-c">;</span> the render function from above</span>
(<span class="pl-k">defn</span> <span class="pl-e">person</span> [{<span class="pl-c1">:keys</span> [name profile-pic-href]}]
  (<span class="pl-en">div</span>
    (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> profile-pic-href})
    name))

<span class="pl-c"><span class="pl-c">;</span> becomes this:</span>
(<span class="pl-k">defsc</span> <span class="pl-e">Person</span> [_ {<span class="pl-c1">:keys</span> [name profile-pic-href]}]
  {:query [<span class="pl-c1">:name</span> <span class="pl-c1">:profile-pic-href</span>]
   <span class="pl-c1">:ident</span> [<span class="pl-c1">:person</span> <span class="pl-c1">:name</span>]}
  (<span class="pl-en">div</span>
    (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> profile-pic-href})
    name))</pre></div>
<p>Let us examine what we see here:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defsc</span> <span class="pl-e">Person</span> 
  [_ <span class="pl-c"><span class="pl-c">;</span> ignore for now</span>

   <span class="pl-c"><span class="pl-c">;</span>; Same as the parameters from the `person` function. This map contains the data we get.</span>
   {<span class="pl-c1">:keys</span> [name profile-pic-href] <span class="pl-c1">:as</span> props}] 
  {<span class="pl-c"><span class="pl-c">;</span>; This describes the data we depend on. No sense in passing you the `profile-pic-href` if you don't need it, for example.</span>
   :query [<span class="pl-c1">:name</span> <span class="pl-c1">:profile-pic-href</span>]
   
   <span class="pl-c"><span class="pl-c">;</span>; this describes where this entity is located in your data</span>
   <span class="pl-c"><span class="pl-c">;</span>; [:person :name] is actually a shorthand for:</span>
   <span class="pl-c1">:ident</span> (<span class="pl-k">fn</span> [] [<span class="pl-c1">:person</span> (<span class="pl-c1">:name</span> props)])}
  (<span class="pl-en">div</span>
    (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> profile-pic-href})
    name))</pre></div>
<p>All well and good.. But how does the data actually get to the component?
Let me simplify.</p>
<p>On the one hand, we had our data with the duplications. There were no idents, just nesting. That kind of format is called a tree.</p>
<p>On the other hand, we would like to have our data <em>normalized</em>, meaning our data is <em>always</em> located at the same position and only that position.</p>
<p>The query and idents helps us translate the one to the other and back.</p>
<pre><code>tree = query + normalized-data
normalized-data = query + tree
</code></pre>
<p>Example:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">def</span> <span class="pl-e">spouse</span> 
  {<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>
   <span class="pl-c1">:profile-pic-href</span> <span class="pl-s"><span class="pl-pds">"</span>alice.png<span class="pl-pds">"</span></span>})

<span class="pl-c"><span class="pl-c">;</span>; Note: The functions in Fulcro are not called `normalize` and `denormalize`, but the idea is the same.</span>

(<span class="pl-k">def</span> <span class="pl-e">normalized-state</span>
  (<span class="pl-en">normalize</span> <span class="pl-c"><span class="pl-c">;</span> called `comp/merge-component` in fulcro</span>
    {}      <span class="pl-c"><span class="pl-c">;</span> The current state. The result of the normalization get deep-merged into this</span>
    Person  <span class="pl-c"><span class="pl-c">;</span> Recipe how to normalize</span>
    spouse) <span class="pl-c"><span class="pl-c">;</span> Data to normalize</span>
<span class="pl-c"><span class="pl-c">;</span>; =&gt; </span>
<span class="pl-c"><span class="pl-c">;</span>; {:person {"Alice"</span>
<span class="pl-c"><span class="pl-c">;</span>;           {:name "Alice"</span>
<span class="pl-c"><span class="pl-c">;</span>;            :profile-pic-href "alice.png"}}}</span>

(<span class="pl-en">denormalize</span> 
    [<span class="pl-c1">:person</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>] <span class="pl-c"><span class="pl-c">;</span> Where to begin the query?</span>
    Person           <span class="pl-c"><span class="pl-c">;</span> Recipe how to denormalize</span>
    normalized-state) <span class="pl-c"><span class="pl-c">;</span> Data to denormalize</span>
<span class="pl-c"><span class="pl-c">;</span>; =&gt; </span>
<span class="pl-c"><span class="pl-c">;</span>; {:name "Alice"</span>
<span class="pl-c"><span class="pl-c">;</span>;  :profile-pic-href "alice.png"}</span>

<span class="pl-c"><span class="pl-c">;</span>; denormalize may look like:</span>
(<span class="pl-en">-&gt;</span> normalized-state
  (<span class="pl-en">get-in</span> [<span class="pl-c1">:person</span> <span class="pl-s"><span class="pl-pds">"</span>Alice<span class="pl-pds">"</span></span>])
  (<span class="pl-en">select-keys</span> (<span class="pl-en">comp/get-query</span> Person)))</pre></div>
<h3>
<a id="user-content-composition" class="anchor" href="#composition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Composition</h3>
<p>You may have noticed the line with the note: <em>Where to begin the query?</em>
In our application, we have <em>one</em> normalized-state. So we want <em>one</em> query to get <em>one</em> tree to pass to our render function.</p>
<p>Coming back to our complete code from before, we can replace the <code>person</code> function with our component:</p>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defsc</span> <span class="pl-e">Person</span> [_ {<span class="pl-c1">:keys</span> [name profile-pic-href]}]
  {:query [<span class="pl-c1">:name</span> <span class="pl-c1">:profile-pic-href</span>]
   <span class="pl-c1">:ident</span> [<span class="pl-c1">:person</span> <span class="pl-c1">:name</span>]}
  (<span class="pl-en">div</span>
    (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> profile-pic-href})
    name))

<span class="pl-c"><span class="pl-c">;</span>; We need an actual function to call for rendering. The prefix `ui-` is idiomatic.</span>
(<span class="pl-k">def</span> <span class="pl-e">ui-person</span> (<span class="pl-en">comp/factory</span> Person {<span class="pl-c1">:keyfn</span> <span class="pl-c1">:name</span>}))

(<span class="pl-k">defn</span> <span class="pl-e">friend-list</span> [friends]
 (<span class="pl-en">ul</span> 
   (<span class="pl-k">for</span> [friend friends]
     (<span class="pl-en">li</span> (<span class="pl-en">ui-person</span> friend)))))

(<span class="pl-k">defn</span> <span class="pl-e">profile-page</span> [{<span class="pl-c1">:keys</span> [spouse friends]}]
  (<span class="pl-en">div</span>
    (<span class="pl-en">p</span> 
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>Spouse<span class="pl-pds">"</span></span>)
      (<span class="pl-en">ui-person</span> spouse))
    (<span class="pl-en">p</span>
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>My Friends<span class="pl-pds">"</span></span>)
      (<span class="pl-en">friend-list</span> friends))))</pre></div>
<p>But the real <em>root</em> of our application is still the <code>profile-page</code> function. That's the function that gets the <em>one tree</em> to render. So this is the place where we need our <em>one query</em> to start.</p>
<p>So let us compose:</p>
<div class="highlight highlight-source-clojure"><pre><span class="pl-c"><span class="pl-c">;</span> First. Let's create a component for the ProfilePage:</span>
(<span class="pl-k">defsc</span> <span class="pl-e">ProfilePage</span> [_ {<span class="pl-c1">:keys</span> [spouse friends]}]

  <span class="pl-c"><span class="pl-c">;</span>; Now to the query. What do we want? (Spoilers: The props above.) </span>
  <span class="pl-c"><span class="pl-c">;</span>; But these props are not primitive data. They are data another component depens on, so we want to include the query of that component. (This is called a join)</span>
  {<span class="pl-c1">:query</span> [{<span class="pl-c1">:spouse</span> (<span class="pl-en">comp/get-query</span> Person)}
           {<span class="pl-c1">:friends</span> (<span class="pl-en">comp/get-query</span> Person)}]} <span class="pl-c"><span class="pl-c">;</span> note there is no special syntax for a to-many join. </span>
  (<span class="pl-en">div</span>
    (<span class="pl-en">p</span> 
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>Spouse<span class="pl-pds">"</span></span>)
      (<span class="pl-en">ui-person</span> spouse))
    (<span class="pl-en">p</span>
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>My Friends<span class="pl-pds">"</span></span>)
      (<span class="pl-en">friend-list</span> friends)))</pre></div>
<h4>
<a id="user-content-where-is-the-ident" class="anchor" href="#where-is-the-ident" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Where is the <code>:ident</code>?</h4>
<p>Not every component requires an ident. In the case of the <em>root</em>-component, it wouldn't even make sense. It would be like: <code>(get-in data [])</code></p>
<h3>
<a id="user-content-the-final-code" class="anchor" href="#the-final-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Final Code</h3>
<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">ns</span> <span class="pl-e">fulcro.tutorial</span>
  (<span class="pl-c1">:require</span> 
    [com.fulcorlogic.fulcro.components <span class="pl-c1">:as</span> comp <span class="pl-c1">:refer</span> [<span class="pl-k">defsc</span>]]
    [com.fulcrologic.fulcro.dom <span class="pl-c1">:as</span> dom <span class="pl-c1">:refer</span> [div p h2 ul li img]]))

(<span class="pl-k">defsc</span> <span class="pl-e">Person</span> [_ {<span class="pl-c1">:keys</span> [name profile-pic-href]}]
  {:query [<span class="pl-c1">:name</span> <span class="pl-c1">:profile-pic-href</span>]
   <span class="pl-c1">:ident</span> [<span class="pl-c1">:person</span> <span class="pl-c1">:name</span>]}
  (<span class="pl-en">div</span>
    (<span class="pl-en">img</span> {<span class="pl-c1">:src</span> profile-pic-href})
    name))

(<span class="pl-k">def</span> <span class="pl-e">ui-person</span> (<span class="pl-en">comp/factory</span> Person {<span class="pl-c1">:keyfn</span> <span class="pl-c1">:name</span>}))

(<span class="pl-k">defn</span> <span class="pl-e">friend-list</span> [friends]
 (<span class="pl-en">ul</span> 
   (<span class="pl-k">for</span> [friend friends]
     (<span class="pl-en">li</span> (<span class="pl-en">ui-person</span> friend)))))

(<span class="pl-k">defsc</span> <span class="pl-e">ProfilePage</span> [_ {<span class="pl-c1">:keys</span> [spouse friends]}]
  {<span class="pl-c1">:query</span> [{<span class="pl-c1">:spouse</span> (<span class="pl-en">comp/get-query</span> Person)}
           {<span class="pl-c1">:friends</span> (<span class="pl-en">comp/get-query</span> Person)}]} 
  (<span class="pl-en">div</span>
    (<span class="pl-en">p</span> 
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>Spouse<span class="pl-pds">"</span></span>)
      (<span class="pl-en">ui-person</span> spouse))
    (<span class="pl-en">p</span>
      (<span class="pl-en">h2</span> <span class="pl-s"><span class="pl-pds">"</span>My Friends<span class="pl-pds">"</span></span>)
      (<span class="pl-en">friend-list</span> friends)))</pre></div>
<h2>
<a id="user-content-follow-up-words" class="anchor" href="#follow-up-words" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Follow-up words</h2>
<p>Fulcro has a lot more <em>things</em> going on. If you read about fulcro, keep in mind: The data normalization is the core thing you need to understand to use fulcro. You need to understand <em>how</em> and <em>why</em> queries and components get composed like they do, to have a chance to understand the rest.</p>
<p>When you feel ready I urge you to go through this in the <a href="https://book.fulcrologic.com/#_getting_started" rel="nofollow">Fulcro Book Chapter 4</a>. There is a lot more you <em>can</em> learn.</p>
]]>
    </content>
  </entry>
  <entry>
    <id>https://blog.ebbinghaus.me/my-first-post.html</id>
    <link href="https://blog.ebbinghaus.me/my-first-post.html"/>
    <title>My first post!</title>
    <published>2021-12-06T00:00:00Z</published>
    <updated>2021-12-06T00:00:00Z</updated>
    <content type="html">
      <![CDATA[<p>This is my first post. Hopefully one of many to come!</p>
]]>
    </content>
  </entry>
  <entry>
    <id>https://blog.ebbinghaus.me/decide-comma20-demo.html</id>
    <link href="https://blog.ebbinghaus.me/decide-comma20-demo.html"/>
    <title>decide: Supporting Participatory Budgeting with Online Argumentation</title>
    <category term="decision-making" label="decision-making"/>
    <category term="participatory budgeting" label="participatory budgeting"/>
    <category term="online-argumentation" label="online-argumentation"/>
    <category term="demo" label="demo"/>
    <published>2020-09-01T00:00:00Z</published>
    <updated>2020-09-01T00:00:00Z</updated>
    <content type="html">
      <![CDATA[<p><strong>Authors</strong>: <a class="author" href="mailto:ebbinghaus@hhu.de">Björn Ebbinghaus</a>, Martin Mauve</p><p><a href='https://wwwcn.cs.uni-duesseldorf.de/publications/publications/library/Ebbinghaus2020a.pdf'>PDF</a></p><p><div class="aspect-w-16 aspect-h-9"> <iframe src="https://www.youtube-nocookie.com/embed/Owexcgd5pOU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> </div></p><h2>Introduction</h2><p>With <i>decide</i> we want to enable a large crowd of participants to decide on a complex issue, such as how to make the best use of a given budget. In particular, we are interested in understanding how online argumentation and online prioritization schemes can be combined to support collective decision-making.</p><p>We have used decide to let our students collectively decide on how to use a real-world budget to improve the computer science course of study at HHU<!&ndash;\cite{Ebbinghaus2019a}&ndash;>. In our demo we will show the setup used in that experiment and report on the outcome.</p><h2>The <i>decide</i> collective decision system</h2><p><i>decide</i> employs a three-step approach to collective decision-making. In the first step participants can introduce proposals. For each proposal an estimated cost is provided by that participant. All participants then use dialog-based argumentation<!&ndash;\cite{Krauthoff2018b}&ndash;> to argue about the validity and priority of the proposals. <!&ndash;This is shown in \autoref{fig:dbas-decide}.&ndash;></p><p>In the second step the proposals are validated. That is to say in our specific experiment we checked if there are any reasons why any of the proposals cannot be realized even if the proposed resources were allocated to it. For example, one proposal required significant construction work which was not feasible. The remaining proposals with the attached argumentation then enter the next step.</p><p>In the final step the participants prioritize the proposals. First, the participants select the proposals that they want to support. Then they order the supported proposals by their own priority <!&ndash;(see \autoref{fig:decide-example})&ndash;>. The arguments attached to the proposals can be viewed and extended in this phase, but no new proposals can be created. The final result is then calculated using a truncated Borda count followed by a greedy collection of proposals which fit the budget.</p><h2>Future Work</h2><p>We have received valuable feedback from the students who used <i>decide</i>. One main issue is that dialog-based argumentation tends to involve the participant in a lengthy exchange of pro and contra arguments. This is good to gain an in-depth understanding of all positions, but it makes it hard to gain a quick overview of the main points. One main issue is therefore to improve the argumentation step and also to test other approaches &ndash;– such as nested pro and contra lists.</p><p>A second issue is the algorithm used to reach a decision. We would like to experiment with other voting schemes and see which of those are considered to be fair by the participants.</p>]]>
    </content>
  </entry>
  <entry>
    <id>https://blog.ebbinghaus.me/biosphere.html</id>
    <link href="https://blog.ebbinghaus.me/biosphere.html"/>
    <title>Biosphere</title>
    <category term="clojure" label="clojure"/>
    <category term="virtual-life" label="virtual-life"/>
    <published>2020-02-29T00:00:00Z</published>
    <updated>2020-02-29T00:00:00Z</updated>
    <content type="html"/>
  </entry>
  <entry>
    <id>https://blog.ebbinghaus.me/jebediah-arguing-with-a-social-bot.html</id>
    <link href="https://blog.ebbinghaus.me/jebediah-arguing-with-a-social-bot.html"/>
    <title>Jebediah – Arguing With a Social Bot</title>
    <category term="dialog-game execution platform" label="dialog-game execution platform"/>
    <category term="online-argumentation" label="online-argumentation"/>
    <category term="conversational ui" label="conversational ui"/>
    <category term="demo" label="demo"/>
    <category term="AI" label="AI"/>
    <published>2018-09-01T00:00:00Z</published>
    <updated>2018-09-01T00:00:00Z</updated>
    <content type="html">
      <![CDATA[<p><strong>Authors</strong>: Christian Meter, <a class="author" href="mailto:ebbinghaus@hhu.de">Björn Ebbinghaus</a>, Martin Mauve</p><p><a href='https://wwwcn.cs.uni-duesseldorf.de/publications/publications/library/Meter2018a.pdf'>PDF</a></p><h2>Introduction</h2><p>In prior work we introduced the <a href='https://dbas.cs.uni-duesseldorf.de'><i>Dialog-Based Argumentation System</i> (D-BAS)</a> [1], a <i>Dialog Game Execution Platform</i> (DGEP) [2] for dialog-based online argumentation. D-BAS allows users to exchange proposals and arguments with each other in the form of a time-shifted dialog where arguments are presented and acted upon one-at-a-time. It is designed as a full-stack, stand alone web-application.</p><p>However, currently, the vast majority of online discussions takes place in social networks such as Facebook or Twitter and not on dedicated argumentation web-sites.  We therefore investigated how the functionality of a dialog-game execution platform, such as D-BAS, can be included in a seamless way into social networks. Our solution to the problem is a social bot called Jebediah. It provides a front-end to DGEPs that can be integrated into social networks in a seamless way.</p><h2><i>Jebediah</i> – a social bot for online argumentation</h2><p><figure>     <img src="assets/jeb.png" alt="Dialog between a user and the conversation agent.">     <figcaption><b>Figure 1.</b> Conversation with Jebediah. On the right side is the user's           input. On the left side are the answers.     </figcaption> </figure></p><p><i>Jebediah</i> is a social bot based on Google’s framework <a href='https://dialogflow.com'>Dialogflow</a> for <i>Artificial Intelligence</i> (AI) development. It connects Dialogflow with a DGEP such as D-BAS’ backend. Dialogflow enables a seamless integration into many popular social networks, e.g. Facebook or Twitter, and provides  processing of text-input from conversations. We leverage this to enable natural language access where the AI is used to parse and interpret the user’s input, whereas the interpreted data is sent to D-BAS’ DGEP, in order to calculate the next steps in the discussion. This setup allows us to directly have a conversation with interested users without the need to leave the current site and to provide a solution to reduce crowded comment sections, e.g. inside a Facebook post.</p><p>Jebediah exposes the full functionality of D-BAS, i.e. collect statements from users, integrate them into a discussion graph and present the next statement to the user (see Fig. 1). It is then possible, in natural language, to interact with arguments and experiences from those users. Users can also start a dialog with the agent and ask for possible entities in the discussion, e.g. topics or other positions.</p><p>Where D-BAS’ interface shows the user a list of possible steps to choose from, this is hardly manageable in a text-only or even voice-only environment. Therefore Jebediah has to lead the user in a way that advances the conversation into deeper levels of the topic, while being flexible enough to react to user actions which are not a usual part of the D-BAS discussion flow. This is even more important in a voice interface where the user has to memorize the current part of the discussion.</p><h2>Related Work</h2><p>Arvina [3] is a system that bears a lot of similarities to our work. With Arvina it is possible to replay previously stored discussions and interact with the recording. Multiple real users can participate in the debate and also add new statements. Jebediah, in contrast, aims at enabling a seamless integration of a DGEP into social networks and at providing a discussion using natural language.</p><h2>References</h2><ul><li>[1] T. Krauthoff, C. Meter, G. Betz, M. Baurmann, and M. Mauve, “D-BAS – A Dialog-Based Online Argumentation System,” in Computational Models of Argument, September 2018, pp. 325–336.</li><li>[2] F. Bex, J. Lawrence, and C. Reed, “Generalising argument dialogue with the dialogue game executionplatform.” in COMMA, 2014, pp. 141–152.</li><li>[3] M. Snaith, J. Lawrence, and C. Reed, “Mixed initiative argument in public deliberation,” Online Deliberation, 2010.</li></ul>]]>
    </content>
  </entry>
  <entry>
    <id>https://blog.ebbinghaus.me/talk-core-async.html</id>
    <link href="https://blog.ebbinghaus.me/talk-core-async.html"/>
    <title>Talk about clojure.core.async</title>
    <summary>I did a talk about core.async for the 'Clojure Meetup Düsseldorf'.</summary>
    <category term="clojure" label="clojure"/>
    <category term="talk" label="talk"/>
    <published>2018-01-24T00:00:00Z</published>
    <updated>2018-01-24T00:00:00Z</updated>
    <content type="html">
      <![CDATA[<p>As a programmer who tries to use <a href="https://clojure.org/" rel="nofollow">Clojure</a><a href="https://clojurescript.org/" rel="nofollow">(Script)</a> wherever possible, I am a frequent visitor of the <a href="https://www.meetup.com/de-DE/Dusseldorf-Clojure-Meetup" rel="nofollow">Clojure Meetup Düsseldorf</a>.
Recently I was asked what clojure tools/libraries I am using, worth sharing. It happens that a couple of days before, I came in contact with <a href="https://github.com/clojure/core.async">core.async</a> while writing a single page application in clojurescript.
One thing led to another, and I agreed to talk about <a href="https://github.com/clojure/core.async">core.async</a> at the next meetup.</p>
<p>As a novice in <a href="https://github.com/clojure/core.async">core.async</a> myself, this was an interesting task ahead.
Having to read a paper about <a href="https://dl.acm.org/citation.cfm?id=502057" rel="nofollow">staged event driven architecture</a> for the lecture <em>Architecture of Distributed Systems</em> introduced me to the advantages of separate running threads and the communication between via queues/channels between them.</p>
<p>After the talk we played around a little with a playground I developed, to test <a href="https://github.com/clojure/core.async">core.async</a> in a scenario of an ant colony.
This playground has the goal to make everything asynchronous, which maybe wasn't an ideal use of async, but it was fun at least to watch the little ants run around.
The code can be found on <a href="https://github.com/clojuredus/async-ants">GitHub</a>.</p>
<p>All in all it was a nice evening, and I hope the listeners have learned something they can use to build great software. If I'm stumbling over something in the future I will definitely consider sharing it on a meetup again.</p>
<p>Thanks to <a href="https://www.invision.de/" rel="nofollow">InVision</a>, which hosted the event and provided us with drinks and <a href="https://www.instagram.com/invision_chefs/" rel="nofollow">great food</a>.
Also check out <a href="https://joyheron.com" rel="nofollow">Joy Heron</a>s wonderful <a href="https://joyheron.com/sketchnote/clojure-meetup/2018/01/24/clojure-meetup.html" rel="nofollow">sketchnote</a>!</p>
<p>The keynote can be found <a href="https://www.icloud.com/keynote/0UasaP9fgxNOu-bwgxZMhH5Tg" rel="nofollow">here</a>.</p>
]]>
    </content>
  </entry>
</feed>
